#!/usr/bin/env python

# This script wraps all parts of the simulator stack, & manages them via
# RESTful commands from a remote client

# TODO this script is really bad for usability as it hides / gobbles all of the
# feedback from Isaac & Unreal Engine... two HUGE parts of the system.
# Debugging issues through this script will not be a fun experience...

from __future__ import print_function

import argparse
import flask
from gevent import event, pywsgi, signal
import glob
import os
import re
import rospy
import shlex
import subprocess
import sys
import time
import yaml

from sensor_msgs.msg import Image, LaserScan
from tf2_msgs.msg import TFMessage

_FILE_COLLISIONS = os.path.abspath('benchbot_collision')
_FILE_DIRTY_STATE = os.path.abspath('benchbot_dirty')

_PATH_ENVS = os.path.abspath('.')
_PATH_ISAAC = os.path.abspath('.')
_PATH_SIMULATOR = os.path.abspath('.')

_ENVS_COMMAND = (
    'cd "$ENVS_PATH" && '
    './IsaacSimProject.sh "$MAP_PATH" -isaac_sim_config_json='
    '"$ISAAC_PATH/apps/carter/carter_sim/bridge_config/carter_full.json"'
    ' -windowed -ResX=960 -ResY=540 -vulkan -game')
_FILE_COMMAND = '[ -f $FILENAME ]'
_DELETE_COMMAND = 'rm -f $FILENAME'
_POSE_COMMAND = (
    'sed -i "0,/\\"pose\\":/{s/\\(\\"pose\\": \\)\\(.*\\)/\\1$START_POSE/}" '
    '$ISAAC_PATH/apps/carter/carter_sim/bridge_config/carter_full_config.json')
_SIMULATOR_COMMAND = ('cd "$SIM_PATH" && '
                      './bazelros run //apps/benchbot_simulator')

_DEV_NULL = open(os.devnull, 'w')

_TOPIC_TIMEOUT = 0.5
_TOPICS = [('/camera/color/image_raw', Image),
           ('/camera/depth/image_raw', Image), ('/scan_laser', LaserScan),
           ('/tf', TFMessage)
          ]  # NOTE: topic types must be imported (cba doing 'magically')!


class SimulatorController(object):

    class _SimulatorInstance(object):

        def __init__(self, map_path, start_pose):
            self.map_path = map_path
            self.start_pose = start_pose

            self._env_process = None
            self._simulator_process = None

        def is_collided(self):
            return (subprocess.Popen(_FILE_COMMAND.replace(
                "$FILENAME", _FILE_COLLISIONS),
                                     shell=True,
                                     executable="/bin/bash").wait() == 0)

        def is_dirty(self):
            return (subprocess.Popen(_FILE_COMMAND.replace(
                "$FILENAME", _FILE_DIRTY_STATE),
                                     shell=True,
                                     executable="/bin/bash").wait() == 0)

        def is_running(self):
            try:
                for t in _TOPICS:
                    rospy.wait_for_message(t[0], t[1], timeout=_TOPIC_TIMEOUT)
                return True
            except rospy.ROSException:
                return False

        def start(self):
            if self.is_running():
                print("Simulator Instance already appears to be running. "
                      "Please stop first before starting again.")
                return False

            # Replace the start pose with the provided value
            if (subprocess.Popen(_POSE_COMMAND.replace(
                    "$START_POSE", self.start_pose).replace(
                        "$ISAAC_PATH", _PATH_ISAAC),
                                 shell=True,
                                 executable='/bin/bash').wait() != 0):
                print("Failed to update the robot starting pose!")
                return False

            # Start the simulator processes
            self._env_process = subprocess.Popen(_ENVS_COMMAND.replace(
                "$ENVS_PATH",
                _PATH_ENVS).replace("$MAP_PATH", self.map_path).replace(
                    "$ISAAC_PATH", _PATH_ISAAC),
                                                 shell=True,
                                                 executable='/bin/bash',
                                                 stdout=_DEV_NULL,
                                                 stderr=_DEV_NULL,
                                                 preexec_fn=os.setsid)
            self._simulator_process = subprocess.Popen(
                _SIMULATOR_COMMAND.replace("$SIM_PATH", _PATH_SIMULATOR),
                shell=True,
                executable='/bin/bash',
                stdout=_DEV_NULL,
                stderr=_DEV_NULL,
                preexec_fn=os.setsid)

            # Wait until the simulator stack has finished starting
            while not self.is_running():
                time.sleep(0.1)
            return True

        def stop(self):
            if not self.is_running():
                print("Simulator instance is not running. Skipping stop.")
                return False

            # Stop all of the main processes
            ps = [self._env_process, self._simulator_process]
            for p in ps:
                os.killpg(os.getpgid(p.pid), signal.SIGINT)
            for p in ps:
                p.wait()
                p = None

            # Clear all temporary files
            subprocess.Popen(_DELETE_COMMAND.replace("$FILENAME",
                                                     _FILE_COLLISIONS),
                             shell=True,
                             executable='/bin/bash').wait()
            subprocess.Popen(_DELETE_COMMAND.replace("$FILENAME",
                                                     _FILE_DIRTY_STATE),
                             shell=True,
                             executable='/bin/bash').wait()

    def __init__(self, map_paths, start_poses, port, auto_start=True):
        self.auto_start = auto_start

        self.simulator_address = 'http://0.0.0.0:' + str(port)

        self._map_selection = None
        self._maps = zip(map_paths, start_poses)

        self._instance = None

    def next(self):
        # Stops any currently running simulators & moves to the next one
        self.stop()
        self._map_selection = (0 if self._map_selection is None or
                               self._map_selection >= len(self._maps) - 1 else
                               self._map_selection + 1)
        self.start()

    def restart(self):
        # Restarts a simulator instance of the current map
        if self._instance is not None:
            self.stop()
        self.start()

    def run(self):
        # Setup all of the simulator management functions
        # TODO some of these should probably be POST methods...
        simulator_flask = flask.Flask(__name__)

        @simulator_flask.route('/', methods=['GET'])
        def __hello():
            return flask.jsonify("Hello, I am the BenchBot simulator")

        @simulator_flask.route('/is_collided', methods=['GET'])
        def __is_collided():
            return flask.jsonify({'is_collided': self._instance.is_collided()})

        @simulator_flask.route('/is_dirty', methods=['GET'])
        def __is_dirty():
            return flask.jsonify({'is_dirty': self._instance.is_dirty()})

        @simulator_flask.route('/is_running', methods=['GET'])
        def __is_running():
            return flask.jsonify({'is_running': self._instance.is_running()})

        @simulator_flask.route('/map_selection_number', methods=['GET'])
        def __map_selection_number():
            return flask.jsonify({'map_selection_number': self._map_selection})

        @simulator_flask.route('/next', methods=['GET'])
        def __next():
            try:
                if (self._map_selection is not None and
                        self._map_selection >= len(self._maps) - 1):
                    raise ValueError(
                        "There is no next map; at the end of the list.")
                self.next()
                success = True
            except Exception as e:
                rospy.logerr(e)
                success = False
            return flask.jsonify({'next_success': success})

        @simulator_flask.route('/reset', methods=['GET'])
        def __reset():
            # Resets the simulator in the current scene
            try:
                self.restart()
                success = self._instance.is_running()
            except Exception as e:
                rospy.logerr(e)
                success = False
            return flask.jsonify({'reset_success': success})

        @simulator_flask.route('/restart', methods=['GET'])
        def __restart():
            # Resets the simulator to the start of the FIRST scene
            try:
                self._map_selection = None
                resp = __reset()
                resp.data = resp.data.replace('reset', 'restart')
                return resp
            except Exception as e:
                rospy.logerr(e)

        # Configure our server
        simulator_server = pywsgi.WSGIServer(
            re.split('http[s]?://', self.simulator_address)[-1],
            simulator_flask)
        evt = event.Event()
        signal(signal.SIGINT, evt.set)
        signal(signal.SIGQUIT, evt.set)
        signal(signal.SIGTERM, evt.set)

        # Run the server & start the simulator stack
        simulator_server.start()
        print("\nSimulator is now available @ '%s' ..." %
              self.simulator_address)
        if self.auto_start:
            print("Starting the simulator stack ... ", end="")
            sys.stdout.flush()
            self.start()
            print("Done")
        evt.wait()
        print("\nShutting down simulator & exiting ...")
        simulator_server.stop()
        self.stop()
        print("Stopped")

    def start(self):
        # Starts the currently selected simulator
        if self._map_selection is None:
            self._map_selection = 0
        self._instance = SimulatorController._SimulatorInstance(
            *self._maps[self._map_selection])
        self._instance.start()

    def stop(self):
        # Stops any running simulator instance
        if self._instance is not None:
            self._instance.stop()


def __valid_file(value):
    path = os.path.abspath(value)
    if not os.path.exists(os.path.dirname(path)):
        raise argparse.ArgumentTypeError(
            "Output file path '%s' is in a non-existent directory" % value)
    return path


def __valid_program_path(value, extra_files, name):
    path = os.path.abspath(value)
    if not os.path.exists(path):
        raise argparse.ArgumentTypeError(
            "Path provided for '%s' does not exist: %s" % (name, value))
    for f in extra_files:
        if not os.path.exists(os.path.join(path, f)):
            raise argparse.ArgumentTypeError(
                "Path provided for '%s' does not contain '%s': %s" %
                (name, f, value))
    return path


def __valid_isaac_path(value):
    return __valid_program_path(value, [], "isaac")


def __valid_envs_path(value):
    return __valid_program_path(value, [_ENVS_COMMAND.split(' ', 4)[3]],
                                "envs")


def __valid_map_paths(value):
    return value.split(':')


def __valid_map_path(map_path, envs_path, metadata_location):
    valid_paths = [
        yaml.safe_load(open(f))['map_path'] for f in glob.glob(
            os.path.join(envs_path, metadata_location, '*.yaml'))
    ]
    if map_path not in valid_paths:
        raise argparse.ArgumentTypeError(
            "Map path '%s' was not found in the environment metadata files at:"
            " %s" % (map_path, os.path.join(envs_path, metadata_location)))
    return map_path


def __valid_metadata_location(envs_path, metadata_location):
    if not os.path.exists(os.path.join(envs_path, metadata_location)):
        raise argparse.ArgumentTypeError(
            "Environment metadata location does not exist: %s" %
            os.path.join(envs_path, metadata_location))
    return metadata_location


def __valid_poses(value):
    # TODO perform a much more robust check for pose validity...
    values = value.split(':')
    for p in values:
        if not re.search(r'\[[0-9\.\-e, ^\]]*\]', value):
            raise argparse.ArgumentTypeError(
                "Start pose is not in expected 7-field vector format: %s" %
                value)
    return values


def __valid_simulator_path(value):
    return __valid_program_path(value, [_SIMULATOR_COMMAND.split(' ', 4)[3]],
                                "simulator")


if __name__ == '__main__':
    rospy.init_node("benchbot_simulator_wrapper")

    # Parse input arguments sanely
    parser = argparse.ArgumentParser(
        description="Controller for the BenchBot simulator stack")
    parser.add_argument('metadata_location')
    parser.add_argument('map_paths', type=__valid_map_paths)
    parser.add_argument('start_poses', type=__valid_poses)
    parser.add_argument('--file-collisions',
                        default='benchbot_collision',
                        type=__valid_file)
    parser.add_argument('--file-dirty-state',
                        default='benchbot_dirty',
                        type=__valid_file)
    parser.add_argument('--path-envs',
                        default=os.path.abspath('.'),
                        type=__valid_envs_path)
    parser.add_argument('--path-isaac',
                        default=os.path.abspath('.'),
                        type=__valid_isaac_path)
    parser.add_argument('--path-simulator',
                        default=os.path.abspath('.'),
                        type=__valid_simulator_path)
    parser.add_argument('--port', type=int, required=True)
    args = parser.parse_args()
    __valid_metadata_location(args.path_envs, args.metadata_location)
    for m in args.map_paths:
        __valid_map_path(m, args.path_envs, args.metadata_location)

    # Update global setttings with supplied values (this is pretty yuck...)
    _FILE_COLLISIONS = args.file_collisions
    _FILE_DIRTY_STATE = args.file_dirty_state
    _PATH_ENVS = args.path_envs
    _PATH_ISAAC = args.path_isaac
    _PATH_SIMULATOR = args.path_simulator

    # Use the controller to run & manage the simulator
    sc = SimulatorController(args.map_paths, args.start_poses, port=args.port)
    sc.run()
