#!/usr/bin/env python

# This script wraps all parts of the simulator stack, & manages them via
# RESTful commands from a remote client

# TODO this script is really bad for usability as it hides / gobbles all of the
# feedback from Isaac & Unreal Engine... two HUGE parts of the system.
# Debugging issues through this script will not be a fun experience...

from __future__ import print_function

import argparse
import flask
from gevent import event, pywsgi, signal
import glob
import os
import re
import rospy
import shlex
import subprocess
import sys
import time
import yaml

from sensor_msgs.msg import Image, LaserScan
from tf2_msgs.msg import TFMessage

_FILE_COLLISIONS = os.path.abspath('benchbot_collision')
_FILE_DIRTY_STATE = os.path.abspath('benchbot_dirty')

_PATH_ENVS = os.path.abspath('.')
_PATH_ISAAC = os.path.abspath('.')
_PATH_SIMULATOR = os.path.abspath('.')

_SIMULATOR_PORT = 10000

_ENVS_COMMAND = (
    './IsaacSimProject.sh "$MAP_PATH" -isaac_sim_config_json='
    '"$ISAAC_PATH/apps/carter/carter_sim/bridge_config/carter_full.json"'
    ' -windowed -ResX=1024 -ResY=720 -vulkan -game')
_FILE_COMMAND = '[ -f $FILENAME ]'
_DELETE_COMMAND = 'rm -f $FILENAME'
_POSE_COMMAND = (
    'sed -i "0,/\\"pose\\":/{s/\\(\\"pose\\": \\)\\(.*\\)/\\1$START_POSE/}" '
    '$ISAAC_PATH/apps/carter/carter_sim/bridge_config/carter_full_config.json')
_SIMULATOR_COMMAND = ('./bazelros run //apps/benchbot_simulator')

_DEV_NULL = open(os.devnull, 'w')

_TOPIC_TIMEOUT = 0.5
_TOPICS = [('/camera/color/image_raw', Image),
           ('/camera/depth/image_raw', Image), ('/scan_laser', LaserScan),
           ('/tf', TFMessage)
          ]  # NOTE: topic types must be imported (cbf doing 'magically')!


class SimulatorController(object):

    class _SimulatorInstance(object):

        def __init__(self, map_path, start_pose):
            self.map_path = map_path
            self.start_pose = start_pose

            self._env_process = None
            self._simulator_process = None

        def is_collided(self):
            return (subprocess.Popen(_FILE_COMMAND.replace(
                "$FILENAME", _FILE_COLLISIONS),
                                     shell="/bin/bash").wait() == 0)

        def is_dirty(self):
            return (subprocess.Popen(_FILE_COMMAND.replace(
                "$FILENAME", _FILE_DIRTY_STATE),
                                     shell="/bin/bash").wait() == 0)

        def is_running(self):
            # return ((self._env_process is not None and
            #          self._env_process.poll() is None) or
            #         (self._simulator_process is not None and
            #          self._simulator_process.poll() is None))
            try:
                for t in _TOPICS:
                    rospy.wait_for_message(t[0], t[1], timeout=_TOPIC_TIMEOUT)
                return True
            except rospy.ROSException as e:
                return False

        def start(self):
            if self.is_running():
                print("Simulator Instance already appears to be running. "
                      "Please stop first before starting again.")
                return False

            # Replace the start pose with the provided value
            if (subprocess.Popen(_POSE_COMMAND.replace(
                    "$START_POSE", self.start_pose).replace(
                        "$ISAAC_PATH", _PATH_ISAAC),
                                 shell='/bin/bash').wait() != 0):
                print("Failed to update the robot starting pose!")
                return False

            # Start the simulator processes
            temp = os.getcwd()
            os.chdir(_PATH_ENVS)
            self._env_process = subprocess.Popen(shlex.split(
                _ENVS_COMMAND.replace("$MAP_PATH", self.map_path).replace(
                    "$ISAAC_PATH", _PATH_ISAAC)),
                                                 preexec_fn=os.setsid)
            os.chdir(_PATH_SIMULATOR)
            # env = os.environ
            # env['PATH'] = '{}:{}'.format(env['PATH'], _PATH_SIMULATOR)
            self._simulator_process = subprocess.Popen(
                shlex.split(_SIMULATOR_COMMAND),
                stdout=_DEV_NULL,
                stderr=_DEV_NULL,
                preexec_fn=os.setsid)
            os.chdir(temp)
            # shell=True,
            # executable='/bin/bash')
            # stdout=_DEV_NULL,
            # stderr=_DEV_NULL)
            # self._env_process = subprocess.Popen('sleep 1000', shell=False)
            # self._simulator_process = subprocess.Popen('sleep 1000',
            #                                            shell=True)

            # Wait until the simulator stack has finished starting
            while not self.is_running():
                time.sleep(0.1)
            return True

        def stop(self):
            if not self.is_running():
                print("Simulator instance is not running. Skipping stop.")
                return False

            # Stop all of the main processes
            ps = [self._env_process, self._simulator_process]
            for p in ps:
                print('Sending signal to {}'.format(str(p)))
                os.killpg(os.getpgid(p.pid), signal.SIGINT)

            for p in reversed(ps):
                print('Waiting for {}'.format(str(p)))
                p.wait()
                p = None

            if self.is_running():
                print('Failed to stop, what a travesty')

            # Clear all temporary files
            subprocess.Popen(_DELETE_COMMAND.replace("$FILENAME",
                                                     _FILE_COLLISIONS),
                             shell='/bin/bash').wait()
            subprocess.Popen(_DELETE_COMMAND.replace("$FILENAME",
                                                     _FILE_DIRTY_STATE),
                             shell='/bin/bash').wait()

    def __init__(self,
                 map_path,
                 start_pose,
                 auto_start=True,
                 port=_SIMULATOR_PORT):
        self.auto_start = auto_start

        self.simulator_address = 'http://0.0.0.0:' + str(port)

        self._instance = SimulatorController._SimulatorInstance(
            map_path, start_pose)

    def _restart(self):
        self._instance.stop()
        self._instance.start()

    def run(self):
        # Setup all of the simulator management functions
        # TODO some of these should probably be POST methods...
        simulator_flask = flask.Flask(__name__)

        @simulator_flask.route('/', methods=['GET'])
        def __hello():
            return flask.jsonify("Hello, I am the BenchBot simulator")

        @simulator_flask.route('/is_collided', methods=['GET'])
        def __is_collided():
            return flask.jsonify({'is_collided': self._instance.is_collided()})

        @simulator_flask.route('/is_dirty', methods=['GET'])
        def __is_dirty():
            return flask.jsonify({'is_dirty': self._instance.is_dirty()})

        @simulator_flask.route('/is_running', methods=['GET'])
        def __is_running():
            return flask.jsonify({'is_running': self._instance.is_running()})

        @simulator_flask.route('/restart', methods=['GET'])
        def __restart():
            try:
                print("Before restart")
                self._restart()
                print("AFTER RESTART")
                return __is_running()
            except Exception as e:
                rospy.logerr(e)
            return flask.jsonify({'restart_success': True})

        # Configure our server
        simulator_server = pywsgi.WSGIServer(
            re.split('http[s]?://', self.simulator_address)[-1],
            simulator_flask)
        evt = event.Event()
        signal(signal.SIGINT, evt.set)
        signal(signal.SIGQUIT, evt.set)
        signal(signal.SIGTERM, evt.set)

        # Run the server & start the simulator stack
        simulator_server.start()
        print("\nSimulator is now available @ '%s' ..." %
              self.simulator_address)
        if self.auto_start:
            print("Starting the simulator stack ... ", end="")
            self._instance.start()
            print("Done")
        evt.wait()
        print("\nShutting down simulator & exiting ...")
        simulator_server.stop()
        self._instance.stop()


def __valid_file(value):
    path = os.path.abspath(value)
    if not os.path.exists(os.path.dirname(path)):
        raise argparse.ArgumentTypeError(
            "Output file path '%s' is in a non-existent directory" % value)
    return path


def __valid_program_path(value, extra_files, name):
    path = os.path.abspath(value)
    if not os.path.exists(path):
        raise argparse.ArgumentTypeError(
            "Path provided for '%s' does not exist: %s" % (name, value))
    for f in extra_files:
        if not os.path.exists(os.path.join(path, f)):
            # TODO REMOVE HACK
            return path
            raise argparse.ArgumentTypeError(
                "Path provided for '%s' does not contain '%s': %s" %
                (name, f, value))
    return path


def __valid_isaac_path(value):
    return __valid_program_path(value, [], "isaac")


def __valid_envs_path(value):
    return __valid_program_path(value, [_ENVS_COMMAND.split(' ', 4)[3]],
                                "envs")


def __valid_map_path(map_path, envs_path, metadata_location):
    valid_paths = [
        yaml.safe_load(open(f))['map_path'] for f in glob.glob(
            os.path.join(envs_path, metadata_location, '*.yaml'))
    ]
    if map_path not in valid_paths:
        raise argparse.ArgumentTypeError(
            "Map path '%s' was not found in the environment metadata files at:"
            " %s" % (map_path, os.path.join(envs_path, metadata_location)))
    return map_path


def __valid_metadata_location(envs_path, metadata_location):
    if not os.path.exists(os.path.join(envs_path, metadata_location)):
        raise argparse.ArgumentTypeError(
            "Environment metadata location does not exist: %s" %
            os.path.join(envs_path, metadata_location))
    return metadata_location


def __valid_pose(value):
    # TODO perform a much more robust check for pose validity...
    if not re.search(r'\[[0-9\.\-e, ^\]]*\]', value):
        raise argparse.ArgumentTypeError(
            "Start pose is not in expected 7-field vector format: %s" % value)
    return value


def __valid_simulator_path(value):
    return __valid_program_path(value, [_SIMULATOR_COMMAND.split(' ', 4)[3]],
                                "simulator")


if __name__ == '__main__':
    rospy.init_node("benchbot_simulator_wrapper")

    # Parse input arguments sanely
    parser = argparse.ArgumentParser(
        description="Controller for the BenchBot simulator stack")
    parser.add_argument('map_path')
    parser.add_argument('metadata_location')
    parser.add_argument('start_pose', type=__valid_pose)
    parser.add_argument('--file-collisions', default='benchbot_collision')
    # type=__valid_file)
    parser.add_argument('--file-dirty-state', default='benchbot_dirty')
    # type=__valid_file)
    parser.add_argument('--path-envs', default=os.path.abspath('.'))
    # type=__valid_envs_path)
    parser.add_argument('--path-isaac', default=os.path.abspath('.'))
    # type=__valid_isaac_path)
    parser.add_argument('--path-simulator', default=os.path.abspath('.'))
    # type=__valid_simulator_path)
    args = parser.parse_args()
    __valid_metadata_location(args.path_envs, args.metadata_location)
    __valid_map_path(args.map_path, args.path_envs, args.metadata_location)

    # Update global setttings with supplied values (this is pretty yuck...)
    _FILE_COLLISIONS = args.file_collisions
    _FILE_DIRTY_STATE = args.file_dirty_state
    _PATH_ENVS = args.path_envs
    _PATH_ISAAC = args.path_isaac
    _PATH_SIMULATOR = args.path_simulator

    # Use the controller to run & manage the simulator
    sc = SimulatorController(args.map_path, args.start_pose)
    sc.run()
